{"version":3,"sources":["template-lint.ts"],"names":[],"mappings":"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","file":"template-lint.js","sourcesContent":["\"use strict\";\r\n\r\nimport {SAXParser, StartTagLocationInfo} from 'parse5';\r\nimport * as parse5 from 'parse5';\r\nimport {Readable} from 'stream';\r\n\r\n/**\r\n* Abstract Lint Rule \r\n*/\r\nexport abstract class Rule {\r\n    public name: string;\r\n    public description: string;\r\n    public errors: string[];\r\n    abstract init(parser: SAXParser, parseState:ParseState)\r\n    finalise() { }\r\n}\r\n\r\n/**\r\n * Rule to ensure non-void elements do not self-close\r\n */\r\nexport class SelfCloseRule extends Rule {\r\n    init(parser: SAXParser, parseState:ParseState) {\r\n\r\n        const voidTags = [\r\n            'area', 'base', 'br', 'col', 'embed', 'hr',\r\n            'img', 'input', 'keygen', 'link', 'meta',\r\n            'param', 'source', 'track', 'wbr'];\r\n\r\n        var self = this;\r\n        \r\n        self.errors = [];\r\n        parser.on('startTag', (name, attrs, selfClosing, location) => {\r\n            if(parseState.scope == 'svg'){\r\n                if(name == 'svg' && selfClosing){\r\n                    let error = \"self-closing element [line: \" + location.line + \"]\";\r\n                    self.errors.push(error);\r\n                }                \r\n                return;\r\n            }\r\n                \r\n            if (selfClosing) {                \r\n                if (voidTags.indexOf(name) < 0) {\r\n                    let error = \"self-closing element [line: \" + location.line + \"]\";\r\n                    self.errors.push(error);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Rule to ensure tags are properly closed. \r\n */\r\nexport class ParserRule extends Rule {\r\n    private parseState:ParseState;\r\n\r\n    init(parser: SAXParser, parseState:ParseState) {  \r\n        this.parseState = parseState;    \r\n        this.errors = [];        \r\n    }\r\n    \r\n    finalise(){\r\n        this.errors = this.parseState.errors;               \r\n    }\r\n}\r\n\r\n/**\r\n *  Node in traversal stack\r\n */\r\nexport class ParseNode {    \r\n    constructor(public scope: string, public name: string, public location:StartTagLocationInfo)\r\n    {        \r\n    }      \r\n}\r\n\r\n/**\r\n *  Helper to maintain the current state of open tags  \r\n */\r\nexport class ParseState {\r\n    public stack: ParseNode[];\r\n    public errors: string[];\r\n    private scopes: string[];\r\n    \r\n    public scope:string;\r\n    \r\n    constructor(scopes?: string[]) {\r\n        if (scopes == null)\r\n            scopes = ['html', 'body', 'template', 'svg'];\r\n\r\n        this.scopes = scopes;\r\n    }\r\n\r\n    init(parser: SAXParser) {\r\n        this.stack = [];\r\n        this.errors = [];\r\n\r\n        var self = this;\r\n        var stack = this.stack;                        \r\n\r\n        parser.on(\"startTag\", (name, attrs, selfClosing, location) => {            \r\n            if (!selfClosing && !self.isVoid(name)) {\r\n                let scope = \"\"\r\n\r\n                if (stack.length > 0)\r\n                    scope = stack[stack.length-1].scope;\r\n                    \r\n                if (self.isScope(name))\r\n                    scope = name;\r\n                    \r\n                self.scope = scope; \r\n                    \r\n                stack.push(new ParseNode(scope, name, location));\r\n            }\r\n        });\r\n        \r\n        parser.on(\"endTag\", (name, location) => {\r\n                        \r\n            if(stack.length <= 0 || stack[stack.length-1].name != name)\r\n            {\r\n                let error = \"mismatched close tag found [line: \" + location.line + \"]\";\r\n                self.errors.push(error);               \r\n            }\r\n            else{\r\n                stack.pop();                \r\n            }           \r\n        });\r\n    }\r\n\r\n    finalise() {\r\n        let stack = this.stack;\r\n        let errors = this.errors;\r\n        if(stack.length > 0)\r\n        {\r\n            let element = stack[stack.length-1]\r\n            let error = \"suspected unclosed element detected [line: \" + element.location.line + \"]\";\r\n            errors.push(error);                  \r\n        }\r\n    }\r\n\r\n    private isVoid(name: string): boolean {\r\n        const voidTags = [\r\n            'area', 'base', 'br', 'col', 'embed', 'hr',\r\n            'img', 'input', 'keygen', 'link', 'meta',\r\n            'param', 'source', 'track', 'wbr'];\r\n\r\n        return voidTags.indexOf(name) >= 0;\r\n    }\r\n\r\n    private isScope(name: string): boolean {\r\n        return this.scopes.indexOf(name) >= 0;\r\n    }\r\n}\r\n\r\nexport class Linter {\r\n\r\n    private rules: Array<Rule>;\r\n\r\n    constructor(rules?: Rule[]) {\r\n        if (!rules)\r\n            rules = [\r\n                new ParserRule(),\r\n                new SelfCloseRule(),\r\n            ];\r\n        this.rules = rules;\r\n    }\r\n\r\n    lint(html: string): Promise<string[]> {\r\n        var parser: SAXParser = new SAXParser({ locationInfo: true });\r\n        var parseState: ParseState = new ParseState();\r\n        var stream: Readable = new Readable();\r\n        \r\n        // must be done before initialising rules\r\n        parseState.init(parser); \r\n\r\n        var rules = this.rules;\r\n\r\n        rules.forEach((rule) => {\r\n            rule.init(parser, parseState);\r\n        });\r\n               \r\n        \r\n        stream.push(html);\r\n        stream.push(null);\r\n        var work = stream.pipe(parser);\r\n\r\n        var completed = new Promise<void>(function (resolve, reject) {\r\n            work.on(\"end\", () => { \r\n                parseState.finalise();\r\n                resolve(); \r\n            });\r\n        });\r\n\r\n        var ruleTasks = [];\r\n\r\n        rules.forEach((rule) => {\r\n            let task = completed.then(() => {      \r\n                rule.finalise();\r\n                return rule.errors\r\n            });\r\n            ruleTasks.push(task);\r\n        });\r\n\r\n        return Promise.all(ruleTasks).then(results => {\r\n\r\n            var all = [];\r\n\r\n            results.forEach(parts => {\r\n                all = all.concat(parts);\r\n            });\r\n\r\n            return all;\r\n        });\r\n    }\r\n}"],"sourceRoot":"../source"}